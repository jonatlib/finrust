//! Timeseries wrapper structures for transport layer
//! 
//! This module provides polars-free wrapper structures for timeseries data
//! generated by the compute module, specifically for account state data.

use chrono::NaiveDate;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use utoipa::ToSchema;

/// A single data point in an account state timeseries
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, ToSchema)]
pub struct AccountStatePoint {
    /// The account identifier
    pub account_id: i32,
    /// The date for this data point
    pub date: NaiveDate,
    /// The account balance/state at this date
    pub balance: Decimal,
}

/// A collection of account state data points forming a timeseries
/// 
/// This is a transport-friendly wrapper that doesn't depend on polars
/// and can be easily serialized/deserialized for API usage.
#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
pub struct AccountStateTimeseries {
    /// All data points in the timeseries
    pub data_points: Vec<AccountStatePoint>,
    /// The date range covered by this timeseries
    pub date_range: DateRange,
}

/// Date range specification for timeseries data
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, ToSchema)]
pub struct DateRange {
    /// Start date (inclusive)
    pub start: NaiveDate,
    /// End date (inclusive)
    pub end: NaiveDate,
}

impl AccountStateTimeseries {
    /// Create a new timeseries from data points
    pub fn new(data_points: Vec<AccountStatePoint>) -> Self {
        let date_range = if data_points.is_empty() {
            // Use today's date as both start and end for empty timeseries
            let today = chrono::Utc::now().date_naive();
            DateRange {
                start: today,
                end: today,
            }
        } else {
            let start = data_points.iter().map(|p| p.date).min().unwrap();
            let end = data_points.iter().map(|p| p.date).max().unwrap();
            DateRange { start, end }
        };

        Self {
            data_points,
            date_range,
        }
    }

    /// Create a new timeseries with explicit date range
    pub fn new_with_range(data_points: Vec<AccountStatePoint>, date_range: DateRange) -> Self {
        Self {
            data_points,
            date_range,
        }
    }

    /// Get all unique account IDs in this timeseries
    pub fn get_account_ids(&self) -> Vec<i32> {
        let mut account_ids: Vec<i32> = self
            .data_points
            .iter()
            .map(|p| p.account_id)
            .collect::<std::collections::HashSet<_>>()
            .into_iter()
            .collect();
        account_ids.sort();
        account_ids
    }

    /// Get all data points for a specific account
    pub fn get_account_data(&self, account_id: i32) -> Vec<&AccountStatePoint> {
        self.data_points
            .iter()
            .filter(|p| p.account_id == account_id)
            .collect()
    }

    /// Get data points for a specific date
    pub fn get_date_data(&self, date: NaiveDate) -> Vec<&AccountStatePoint> {
        self.data_points
            .iter()
            .filter(|p| p.date == date)
            .collect()
    }

    /// Get the balance for a specific account on a specific date
    pub fn get_balance(&self, account_id: i32, date: NaiveDate) -> Option<Decimal> {
        self.data_points
            .iter()
            .find(|p| p.account_id == account_id && p.date == date)
            .map(|p| p.balance)
    }

    /// Get the latest balance for a specific account
    pub fn get_latest_balance(&self, account_id: i32) -> Option<(NaiveDate, Decimal)> {
        self.data_points
            .iter()
            .filter(|p| p.account_id == account_id)
            .max_by_key(|p| p.date)
            .map(|p| (p.date, p.balance))
    }

    /// Get all dates in the timeseries (sorted)
    pub fn get_dates(&self) -> Vec<NaiveDate> {
        let mut dates: Vec<NaiveDate> = self
            .data_points
            .iter()
            .map(|p| p.date)
            .collect::<std::collections::HashSet<_>>()
            .into_iter()
            .collect();
        dates.sort();
        dates
    }

    /// Get the number of data points
    pub fn len(&self) -> usize {
        self.data_points.len()
    }

    /// Check if the timeseries is empty
    pub fn is_empty(&self) -> bool {
        self.data_points.is_empty()
    }

    /// Group data points by account ID
    pub fn group_by_account(&self) -> HashMap<i32, Vec<&AccountStatePoint>> {
        let mut grouped = HashMap::new();
        for point in &self.data_points {
            grouped
                .entry(point.account_id)
                .or_insert_with(Vec::new)
                .push(point);
        }

        // Sort each account's data points by date
        for points in grouped.values_mut() {
            points.sort_by_key(|p| p.date);
        }

        grouped
    }

    /// Filter data points by date range
    pub fn filter_by_date_range(&self, start: NaiveDate, end: NaiveDate) -> Self {
        let filtered_points: Vec<AccountStatePoint> = self
            .data_points
            .iter()
            .filter(|p| p.date >= start && p.date <= end)
            .cloned()
            .collect();

        Self::new_with_range(filtered_points, DateRange { start, end })
    }

    /// Filter data points by account IDs
    pub fn filter_by_accounts(&self, account_ids: &[i32]) -> Self {
        let filtered_points: Vec<AccountStatePoint> = self
            .data_points
            .iter()
            .filter(|p| account_ids.contains(&p.account_id))
            .cloned()
            .collect();

        Self::new_with_range(filtered_points, self.date_range.clone())
    }
}

impl DateRange {
    /// Create a new date range
    pub fn new(start: NaiveDate, end: NaiveDate) -> Self {
        Self { start, end }
    }

    /// Check if a date is within this range (inclusive)
    pub fn contains(&self, date: NaiveDate) -> bool {
        date >= self.start && date <= self.end
    }

    /// Get the number of days in this range
    pub fn days(&self) -> i64 {
        (self.end - self.start).num_days() + 1
    }

    /// Get a human-readable description of the range
    pub fn description(&self) -> String {
        format!("{} to {}", self.start, self.end)
    }
}

impl AccountStatePoint {
    /// Create a new account state point
    pub fn new(account_id: i32, date: NaiveDate, balance: Decimal) -> Self {
        Self {
            account_id,
            date,
            balance,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_data() -> Vec<AccountStatePoint> {
        vec![
            AccountStatePoint::new(1, NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(), Decimal::new(1000, 2)),
            AccountStatePoint::new(1, NaiveDate::from_ymd_opt(2024, 1, 2).unwrap(), Decimal::new(1100, 2)),
            AccountStatePoint::new(2, NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(), Decimal::new(2000, 2)),
            AccountStatePoint::new(2, NaiveDate::from_ymd_opt(2024, 1, 2).unwrap(), Decimal::new(1900, 2)),
        ]
    }

    #[test]
    fn test_timeseries_creation() {
        let data = create_test_data();
        let timeseries = AccountStateTimeseries::new(data);

        assert_eq!(timeseries.len(), 4);
        assert!(!timeseries.is_empty());
        assert_eq!(timeseries.get_account_ids(), vec![1, 2]);
        assert_eq!(
            timeseries.date_range.start,
            NaiveDate::from_ymd_opt(2024, 1, 1).unwrap()
        );
        assert_eq!(
            timeseries.date_range.end,
            NaiveDate::from_ymd_opt(2024, 1, 2).unwrap()
        );
    }

    #[test]
    fn test_get_balance() {
        let data = create_test_data();
        let timeseries = AccountStateTimeseries::new(data);

        assert_eq!(
            timeseries.get_balance(1, NaiveDate::from_ymd_opt(2024, 1, 1).unwrap()),
            Some(Decimal::new(1000, 2))
        );
        assert_eq!(
            timeseries.get_balance(2, NaiveDate::from_ymd_opt(2024, 1, 2).unwrap()),
            Some(Decimal::new(1900, 2))
        );
        assert_eq!(
            timeseries.get_balance(3, NaiveDate::from_ymd_opt(2024, 1, 1).unwrap()),
            None
        );
    }

    #[test]
    fn test_get_latest_balance() {
        let data = create_test_data();
        let timeseries = AccountStateTimeseries::new(data);

        assert_eq!(
            timeseries.get_latest_balance(1),
            Some((NaiveDate::from_ymd_opt(2024, 1, 2).unwrap(), Decimal::new(1100, 2)))
        );
        assert_eq!(
            timeseries.get_latest_balance(2),
            Some((NaiveDate::from_ymd_opt(2024, 1, 2).unwrap(), Decimal::new(1900, 2)))
        );
        assert_eq!(timeseries.get_latest_balance(3), None);
    }

    #[test]
    fn test_filter_by_date_range() {
        let data = create_test_data();
        let timeseries = AccountStateTimeseries::new(data);

        let filtered = timeseries.filter_by_date_range(
            NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),
            NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),
        );

        assert_eq!(filtered.len(), 2);
        assert_eq!(filtered.get_account_ids(), vec![1, 2]);
    }

    #[test]
    fn test_filter_by_accounts() {
        let data = create_test_data();
        let timeseries = AccountStateTimeseries::new(data);

        let filtered = timeseries.filter_by_accounts(&[1]);

        assert_eq!(filtered.len(), 2);
        assert_eq!(filtered.get_account_ids(), vec![1]);
    }

    #[test]
    fn test_date_range() {
        let start = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
        let end = NaiveDate::from_ymd_opt(2024, 1, 5).unwrap();
        let range = DateRange::new(start, end);

        assert!(range.contains(NaiveDate::from_ymd_opt(2024, 1, 3).unwrap()));
        assert!(!range.contains(NaiveDate::from_ymd_opt(2024, 1, 6).unwrap()));
        assert_eq!(range.days(), 5);
        assert_eq!(range.description(), "2024-01-01 to 2024-01-05");
    }
}
