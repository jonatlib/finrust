//! Statistics wrapper structures for transport layer
//! 
//! This module provides polars-free wrapper structures for statistics
//! generated by the compute module.

use chrono::NaiveDate;
use rust_decimal::Decimal;

/// Statistics for a specific account and time period
/// 
/// This is a transport-friendly wrapper that doesn't depend on polars
/// and can be easily serialized/deserialized for API usage.
#[derive(Debug, Clone, PartialEq)]
pub struct AccountStatistics {
    /// The account identifier
    pub account_id: i32,
    /// Minimum account state in the period
    pub min_state: Option<Decimal>,
    /// Maximum account state in the period
    pub max_state: Option<Decimal>,
    /// Average expense in the period
    pub average_expense: Option<Decimal>,
    /// Average income in the period
    pub average_income: Option<Decimal>,
    /// Upcoming expenses in the period
    pub upcoming_expenses: Option<Decimal>,
    /// Account state at the end of the period
    pub end_of_period_state: Option<Decimal>,
}

/// Collection of statistics for multiple accounts
/// 
/// This structure groups statistics by time period and provides
/// convenient access methods.
#[derive(Debug, Clone)]
pub struct AccountStatisticsCollection {
    /// The time period these statistics cover
    pub period: TimePeriod,
    /// Statistics for each account
    pub statistics: Vec<AccountStatistics>,
}

/// Time period specification for statistics
#[derive(Debug, Clone, PartialEq)]
pub enum TimePeriod {
    /// Statistics for a specific year
    Year(i32),
    /// Statistics for a specific month in a year
    Month { year: i32, month: u32 },
    /// Statistics for a custom date range
    DateRange { start: NaiveDate, end: NaiveDate },
}

impl AccountStatisticsCollection {
    /// Create a new statistics collection
    pub fn new(period: TimePeriod, statistics: Vec<AccountStatistics>) -> Self {
        Self { period, statistics }
    }

    /// Get statistics for a specific account
    pub fn get_account_statistics(&self, account_id: i32) -> Option<&AccountStatistics> {
        self.statistics.iter().find(|s| s.account_id == account_id)
    }

    /// Get all account IDs in this collection
    pub fn get_account_ids(&self) -> Vec<i32> {
        self.statistics.iter().map(|s| s.account_id).collect()
    }

    /// Get the number of accounts in this collection
    pub fn account_count(&self) -> usize {
        self.statistics.len()
    }

    /// Check if the collection is empty
    pub fn is_empty(&self) -> bool {
        self.statistics.is_empty()
    }
}

impl TimePeriod {
    /// Create a year period
    pub fn year(year: i32) -> Self {
        Self::Year(year)
    }

    /// Create a month period
    pub fn month(year: i32, month: u32) -> Self {
        Self::Month { year, month }
    }

    /// Create a date range period
    pub fn date_range(start: NaiveDate, end: NaiveDate) -> Self {
        Self::DateRange { start, end }
    }

    /// Get a human-readable description of the period
    pub fn description(&self) -> String {
        match self {
            Self::Year(year) => format!("Year {}", year),
            Self::Month { year, month } => format!("{:04}-{:02}", year, month),
            Self::DateRange { start, end } => format!("{} to {}", start, end),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_account_statistics_creation() {
        let stats = AccountStatistics {
            account_id: 1,
            min_state: Some(Decimal::new(100, 2)),
            max_state: Some(Decimal::new(500, 2)),
            average_expense: Some(Decimal::new(200, 2)),
            average_income: Some(Decimal::new(300, 2)),
            upcoming_expenses: Some(Decimal::new(150, 2)),
            end_of_period_state: Some(Decimal::new(400, 2)),
        };

        assert_eq!(stats.account_id, 1);
        assert_eq!(stats.min_state, Some(Decimal::new(100, 2)));
    }

    #[test]
    fn test_statistics_collection() {
        let stats1 = AccountStatistics {
            account_id: 1,
            min_state: Some(Decimal::new(100, 2)),
            max_state: Some(Decimal::new(500, 2)),
            average_expense: None,
            average_income: None,
            upcoming_expenses: None,
            end_of_period_state: None,
        };

        let stats2 = AccountStatistics {
            account_id: 2,
            min_state: Some(Decimal::new(200, 2)),
            max_state: Some(Decimal::new(600, 2)),
            average_expense: None,
            average_income: None,
            upcoming_expenses: None,
            end_of_period_state: None,
        };

        let collection = AccountStatisticsCollection::new(
            TimePeriod::year(2024),
            vec![stats1, stats2],
        );

        assert_eq!(collection.account_count(), 2);
        assert!(!collection.is_empty());
        assert_eq!(collection.get_account_ids(), vec![1, 2]);
        assert!(collection.get_account_statistics(1).is_some());
        assert!(collection.get_account_statistics(3).is_none());
    }

    #[test]
    fn test_time_period_descriptions() {
        assert_eq!(TimePeriod::year(2024).description(), "Year 2024");
        assert_eq!(TimePeriod::month(2024, 6).description(), "2024-06");
        
        let start = NaiveDate::from_ymd_opt(2024, 1, 1).unwrap();
        let end = NaiveDate::from_ymd_opt(2024, 12, 31).unwrap();
        assert_eq!(
            TimePeriod::date_range(start, end).description(),
            "2024-01-01 to 2024-12-31"
        );
    }
}